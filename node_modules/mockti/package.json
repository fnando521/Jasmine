{
  "author": {
    "name": "Russ Frank",
    "email": "me@russfrank.us"
  },
  "name": "mockti",
  "description": "mocking for Titanium",
  "version": "1.1.1",
  "homepage": "https://github.com/russfrank/mockti",
  "scripts": {
    "test": "mocha -R spec -u tdd test.js"
  },
  "repository": {
    "type": "git",
    "url": "github.com:russfrank/mockti"
  },
  "main": "mockti.js",
  "dependencies": {
    "underscore": "*",
    "eventemitter2": "*",
    "MD5": "1.0.0",
    "request": "2.9.203"
  },
  "files": [
    "api.jsca",
    "mockti.js",
    "README.md",
    "LICENSE",
    "test.js"
  ],
  "devDependencies": {
    "mocha": "*",
    "nock": "*"
  },
  "optionalDependencies": {},
  "engines": {
    "node": "*"
  },
  "readme": "# mockti\n\n[![build status](https://secure.travis-ci.org/rf/mockti.png)](http://travis-ci.org/rf/mockti)\n\n**mockti** is a mocking framework for Titanium.  It loads up a `jsca` description\nof the Titanium API and creates a `Titanium` object with all of the proper\nobjects and methods for testing code.  Every proxy is an emitter (as in Ti\nitself).  Methods also emit an event `function::name` when invoked.\n\nThis is a continuation of my exploration of testing in Titanium.\nIt's a [Zombie.js](http://zombie.labnotes.org/) style\napproach to the problem; rather than running inside of the emulators and \nsimulating events, we instead just simulate the environment in pure \njavascript. This may prove useful for testing certain types of user interfaces \nand code.  I've found it helpful for mocking requests for testing my \nnetwork code.\n\nAlternatively, one could use some test runner with \n[this](https://github.com/russfrank/spade). This is the PhantomJS style approach.\n\n## How to use it\n\nInstall it like this\n\n```shell\n$ npm i mockti\n```\n\nThen, use it like this\n\n```javascript\nvar mockti = require('mockti');\n\n// make it global \nTi = mockti();\n\nvar xhr = Titanium.Network.createHTTPClient();\nvar view = Ti.UI.createView();\n```\n\nThe `mockti()` function takes as an argument the path to an `api.jsca` file.\nThese are included with every sdk build. If you don't pass a path, it'll use\nthe bundled `api.jsca`, which currently is from 3.1.0 GA.\n\nYou'll probably want to require() some of the code in your `Resources` folder.\nCurrently I have my project setup with a `test` folder which has a couple tests;\nthese require code out of Resources after requiring `mockti`.  Then, I attempt\nrequests, make assertions, etc.\n\nYou can also make http requests, which will go through the npm `request` module.\nCheck out [nock](http://github.com/flatiron/nock) if you'd like to mock these\nrequests.\n\n## Type Assertions\n\nSimple types are asserted. For example, functions that accept a number or string\nwill have their argument's type asserted.\n\n## License\n\nMIT.\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/russfrank/mockti/issues"
  },
  "_id": "mockti@1.1.1",
  "dist": {
    "shasum": "3db65698ff1440a57401e4e6da7463578678418b"
  },
  "_from": "mockti@",
  "_resolved": "https://registry.npmjs.org/mockti/-/mockti-1.1.1.tgz"
}
